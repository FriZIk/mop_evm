;Разработать подпрограмму, которая удаляет, начиная с заданной позиции
;строки, указанное число символов. Разработать программу, которая вводит с
;клавиатуры строку, вводит позицию и длину удаляемой части строки и
;удаляет эту часть [14].

    locals __
    model small
    stack 100h
    dataseg
MESS1 db 0dh,0ah,0dh,0ah,"QWETY",0dh,0ah,"$"
MESS2 db 0dh,0ah,"Введите позицию: $"
MESS3 db 0dh,0ah,"Введите число удаляемых символов: $"
MESS4 db 0dh,0ah,0dh,0ah,"Строка после удаления:",0dh,0ah,"$"
S_BUFLEN db 80 ; Макс. длина строки
S_FACTLEN db ? ; Длина фактически введенной строки
S_INPBUF db 80 dup(?) ; Введенная строка
N_BUFLEN db 3 ; Макс. длина числа при вводе
N_FACTLEN db ? ; Фактическая длина
N_INPBUF db 3 dup(?) ; Строка представления числа
POSDEL dw ? ; Позиция, начиная с которой удаляем
LENDEL dw ? ; Сколько символов удалить
codeseg
startupcode

; Ввод строки
MLOOP: lea DX, MESS1
    mov AH, 09h
    int 21h ;Приглашение к вводу строки
    lea DX, S_BUFLEN
    mov AH, 0Ah
    int 21h ;Ввод строки
    mov BL, S_FACTLEN
    cmp BL, 0 ;Строка пустая?
    jne LLL0 ;Нет – продолжать
    jmp QUIT ;Закончить работу
LLL0: mov BH, 0
    ;Дополнить длину до слова
    add BX, 2 ; и получить адрес позиции
    add BX, DX ; сразу после конца строки
    mov byte ptr [BX],0 ;Записать признак конца строки
    ; Ввод позиции удаления
LLL1: lea DX, MESS2 ;Приглашение
    mov AH, 09h; к вводу
    int 21h; позиции удаления
    lea DX, N_BUFLEN
    mov AH, 0Ah
    int 21h ;Ввод строки числа
    lea BX, N_INPBUF;Адрес строки представления числа
    mov CL, N_FACTLEN;Длина этой строки
    call VAL ;Перевод в целое число
    jc LLL1 ;Ошибка? – повторить ввод
    cmp AL, 0 ;Ноль?
    je LLL1 ;Повторить ввод
    cmp AL, S_FACTLEN;Превышает длину строки?
    jg LLL1 ;Повторить ввод
    mov POSDEL, AX ;Запомнить позицию удаления
    ; Ввод длины удаляемой части
LLL2: lea DX, MESS3 ;Приглашение
    mov AH, 09h ; к вводу
    int 21h ; числа удаляемых
    lea DX, N_BUFLEN
    mov AH, 0Ah
    int 21h ;Ввод строки числа удаляемых
    lea BX, N_INPBUF ;Адрес строки представления числа
    mov CL, N_FACTLEN;Длина этой строки
    call VAL ;Перевод в целое число
    jc LLL2 ;Ошибка? – повторить ввод
    mov LENDEL, AX ;Запомнить число удаляемых
    add AX, POSDEL ;Подсчитать, не выходит ли
    dec AX ; удаляемая часть
    cmp AL, S_FACTLEN ; за конец строки?
    jg LLL2 ;Если да – повторить ввод
    ; Занесение параметров в стек и вызов подпрограммы удаления
    lea AX, S_INPBUF
    push AX ;1-й параметр – адрес строки
    push POSDEL ;2-й параметр – позиция удаления
    push LENDEL ;3-й параметр – число удаляемых
    call DELSUBS ;Вызов подпрограммы
    ; Вывод результата
    lea DX, MESS4
    mov AH, 09h
    int 21h;Заголовок вывода
    lea BX, S_INPBUF
    mov CX, 80
LLL3: cmp byte ptr [BX],0 ;Цикл поиска конца строки и выход
    je LLL4 ; если найден конец строки
    inc BX ;Сдвиг по строке
    loop LLL3
LLL4: mov byte ptr [BX],'$';Заменить признак конца строки
    lea DX, S_INPBUF
    mov AH, 09h
    int 21h ; Вывод результата
    jmp MLOOP ; На повторение работы
QUIT: exitcode 0
;Действие:
; функция вычисляет целое число по его строковому представлению.
; Результат не может быть больше 255.
; Для неверно введенных чисел устанавливает флаг переноса
; Параметры:
; BX – адрес строки представления числа
; CX – длина этой строки
; Возвращает:
; CF – установлен, если в строке не цифры, AX – не определен
; сброшен, строка нормальная, AX – число
; AX – преобразованное число, если сброшен
VAL proc near
push DX ;Сохранить все изменяемые регистры,
; кроме AX, в котором результат
mov CH, 0 ;Расширяем длину до слова
mov AX, 0 ;Начальное значение результата
mov DL, 10 ;Основание системы счисления
__1: imul DL ;Умножить на основание
    jc __2 ;Переполнение байта?
    mov DH, [BX] ;Очередная цифра
    sub DH, '0' ;Получить значение цифры
    jl __2 ;Это была не цифра!
    cmp DH, 9
    jg __2 ;Это опять же была не цифра!
    add AL, DH ;+ значение цифры к результату
    jc __2 ;Переполнение байта?
    inc BX ;Сдвиг по строке
    loop __1 ;Цикл по строке
    jmp __3 ;Нормальное число
__2: stc ;Было переполнение – устанавливаем CF
__3: pop DX ;Восстановить все, что сохраняли
    ret
VAL endp
; Подпрограмма удаления подстроки
DELSUBS proc near
    arg __Ldel: word, __Pdel: word, __StrAdr: word = __ArgSize
;Paramsstruc;Структура стека после сохранения BP
; SaveBP dw ? ; Сохраненное значение BP
; SaveIP dw ? ; Адрес возврата
; LDel dw ? ; 3-й параметр – число удаляемых
; PDel dw? ; 2-й параметр – позиция удаления
; StrAdr dw ? ; 1-й параметр – адрес строки
;Params ends
    push BP ;Сохранить BP
    mov BP, SP ;Теперь BP адресует стек ПОСЛЕ сохранения BP,
    ; но ДО сохранения остальных регистров
    push ES AX SI DI CX ;Сохранить все изменяемые регистры
    mov AX,DS ; ES будет указывать на
    mov ES,AX ; сегмент данных
    mov DI,__StrAdr ; Установить в DI адрес,
    add DI,__PDel ; куда надо
    dec DI ; пересылать символы
    mov SI,DI ;А в SI – адрес,
    add SI,__LDel ; откуда их пересылать
    cld ;Продвигаться от начала строки к концу
__REPEAT:
    movsb
    cmp byte ptr [SI-1], 0
    jne __REPEAT
    pop CX DI SI AX ES ;Восстановить все, что сохраняли
    pop BP
    ret __ArgSize ;Убрать из стека 3 параметра-слова
DELSUBS endp
end